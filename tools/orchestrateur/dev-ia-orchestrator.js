#!/usr/bin/env node

/**
 * @criticality HIGH
 * @depends package.json, .cbdrc.json, tools/cbd/
 * @description Orchestrateur central Dev:IA - Commande unique pour workflow complet
 * @phase ALL - Applicable √† toutes les phases
 * @category orchestration
 * @version 2.0
 * @author CBD System
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

class DevIAOrchestrator {
    constructor() {
        this.projectRoot = process.cwd();
        this.logFile = path.join(this.projectRoot, 'LOG_DEV_IA.md');
        this.startTime = Date.now();
        this.steps = [];
        this.errors = [];
    }

    /**
     * Workflow principal d'orchestration
     */
    async execute() {
        console.log('üöÄ Dev:IA Orchestrator - D√©marrage du workflow automatis√©');
        
        try {
            await this.step1_ValidateCBD();
            await this.step2_ValidateRoadmap();
            await this.step3_CheckEnvironment();
            await this.step4_RunTests();
            await this.step5_AnalyzeQuality();
            await this.step6_SecurityAudit();
            await this.step7_LearnFromPostMortem();
            await this.step8_SmartCommit();
            await this.step9_GenerateReport();
            
            console.log('‚úÖ Workflow Dev:IA compl√©t√© avec succ√®s');
            return true;
            
        } catch (error) {
            console.error('‚ùå √âchec du workflow Dev:IA:', error.message);
            await this.handleError(error);
            return false;
        }
    }

    /**
     * √âtape 1: Validation CBD
     */
    async step1_ValidateCBD() {
        const stepName = 'Validation CBD';
        console.log(`üîç ${stepName}...`);
        
        try {
            // Pour l'orchestrateur, on fait une validation basique du format
            const cbdPath = path.join(this.projectRoot, '..', 'MyDevFramework', 'tools', 'cbd', 'cbd-validator.js');
            
            // Simuler un prompt CBD valide pour l'orchestrateur
            const samplePrompt = '[CONTEXT] Dev:IA Orchestrator [FILE] orchestrator [CMD] npm run dev:ia [TEST] automated [CHECK] workflow completed';
            
            const result = execSync(`node "${cbdPath}" "${samplePrompt}"`, { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            this.logStep(stepName, 'SUCCESS', 'CBD format valid√© pour orchestrateur');
            
        } catch (error) {
            // Si le validateur n'est pas disponible, on continue quand m√™me
            console.log('‚ö†Ô∏è CBD Validator non disponible, passage en mode d√©grad√©');
            this.logStep(stepName, 'WARNING', 'CBD Validator non disponible');
        }
    }

    /**
     * √âtape 2: Validation Roadmap
     */
    async step2_ValidateRoadmap() {
        const stepName = 'Validation Roadmap';
        console.log(`üó∫Ô∏è ${stepName}...`);
        
        try {
            const roadmapPath = path.join(this.projectRoot, '..', 'MyDevFramework', 'tools', 'cbd', 'roadmap-checker.js');
            
            // V√©rifier si le fichier existe
            if (fs.existsSync(roadmapPath)) {
                const result = execSync(`node "${roadmapPath}"`, { 
                    encoding: 'utf8',
                    cwd: this.projectRoot 
                });
                
                this.logStep(stepName, 'SUCCESS', result);
            } else {
                console.log('‚ö†Ô∏è Roadmap Checker non disponible, validation basique');
                this.logStep(stepName, 'WARNING', 'Roadmap Checker non disponible');
            }
            
        } catch (error) {
            console.log('‚ö†Ô∏è Roadmap validation non disponible, passage en mode d√©grad√©');
            this.logStep(stepName, 'WARNING', 'Roadmap validation non disponible');
        }
    }

    /**
     * √âtape 3: V√©rification Environnement
     */
    async step3_CheckEnvironment() {
        const stepName = 'V√©rification Environnement';
        console.log(`‚öôÔ∏è ${stepName}...`);
        
        try {
            const result = execSync('npm run check:env', { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            this.logStep(stepName, 'SUCCESS', result);
            
        } catch (error) {
            this.logStep(stepName, 'WARNING', error.message);
            // Non bloquant pour l'environnement
        }
    }

    /**
     * √âtape 4: Tests Critiques
     */
    async step4_RunTests() {
        const stepName = 'Tests Critiques';
        console.log(`üß™ ${stepName}...`);
        
        try {
            const result = execSync('npm run test:critical', { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            this.logStep(stepName, 'SUCCESS', result);
            
        } catch (error) {
            this.logStep(stepName, 'ERROR', error.message);
            throw new Error(`Critical Tests failed: ${error.message}`);
        }
    }

    /**
     * √âtape 5: Analyse Qualit√©
     */
    async step5_AnalyzeQuality() {
        const stepName = 'Analyse Qualit√©';
        console.log(`üìä ${stepName}...`);
        
        try {
            // Lint
            const lintResult = execSync('npm run lint', { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            // Build pour v√©rifier compilation
            const buildResult = execSync('npm run build', { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            this.logStep(stepName, 'SUCCESS', `Lint: OK, Build: OK`);
            
        } catch (error) {
            this.logStep(stepName, 'ERROR', error.message);
            throw new Error(`Quality Analysis failed: ${error.message}`);
        }
    }

    /**
     * √âtape 6: Audit S√©curit√©
     */
    async step6_SecurityAudit() {
        const stepName = 'Audit S√©curit√©';
        console.log(`üõ°Ô∏è ${stepName}...`);
        
        try {
            const result = execSync('npm audit --audit-level high', { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            this.logStep(stepName, 'SUCCESS', 'Aucune vuln√©rabilit√© haute d√©tect√©e');
            
        } catch (error) {
            // npm audit retourne exit code 1 m√™me pour warnings
            if (error.message.includes('high')) {
                this.logStep(stepName, 'ERROR', error.message);
                throw new Error(`Security vulnerabilities found: ${error.message}`);
            } else {
                this.logStep(stepName, 'WARNING', error.message);
            }
        }
    }

    /**
     * √âtape 7: Apprentissage Post-Mortem
     */
    async step7_LearnFromPostMortem() {
        const stepName = 'Apprentissage Post-Mortem';
        console.log(`üß† ${stepName}...`);
        
        try {
            const learningPath = path.join(this.projectRoot, '..', 'MyDevFramework', 'tools', 'learning', 'postmortem-learning.js');
            
            if (fs.existsSync(learningPath)) {
                const result = execSync(`node "${learningPath}"`, { 
                    encoding: 'utf8',
                    cwd: this.projectRoot,
                    stdio: 'pipe'
                });
                
                this.logStep(stepName, 'SUCCESS', 'Patterns analys√©s et am√©liorations g√©n√©r√©es');
            } else {
                console.log('‚ö†Ô∏è Syst√®me d\'apprentissage non disponible');
                this.logStep(stepName, 'WARNING', 'Learning system non disponible');
            }
            
        } catch (error) {
            console.log('‚ö†Ô∏è Apprentissage post-mortem non disponible');
            this.logStep(stepName, 'WARNING', 'Post-mortem learning non disponible');
        }
    }

    /**
     * √âtape 8: Commit Intelligent
     */
    async step8_SmartCommit() {
        const stepName = 'Commit Intelligent';
        console.log(`üìù ${stepName}...`);
        
        try {
            // V√©rifier s'il y a des changements
            const gitStatus = execSync('git status --porcelain', { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            if (gitStatus.trim()) {
                // G√©n√©rer message de commit intelligent
                const commitMessage = this.generateSmartCommitMessage();
                
                execSync('git add .', { cwd: this.projectRoot });
                execSync(`git commit -m "${commitMessage}"`, { cwd: this.projectRoot });
                
                this.logStep(stepName, 'SUCCESS', `Commit: ${commitMessage}`);
            } else {
                this.logStep(stepName, 'INFO', 'Aucun changement √† commiter');
            }
            
        } catch (error) {
            this.logStep(stepName, 'WARNING', error.message);
            // Non bloquant pour le commit
        }
    }

    /**
     * √âtape 9: G√©n√©ration Rapport
     */
    async step9_GenerateReport() {
        const stepName = 'G√©n√©ration Rapport';
        console.log(`üìã ${stepName}...`);
        
        const duration = Date.now() - this.startTime;
        const report = this.generateDetailedReport(duration);
        
        fs.writeFileSync(this.logFile, report, 'utf8');
        
        console.log(`üìä Rapport d√©taill√© g√©n√©r√©: ${this.logFile}`);
        this.logStep(stepName, 'SUCCESS', `Rapport g√©n√©r√© en ${duration}ms`);
    }

    /**
     * Gestion des erreurs avec post-mortem
     */
    async handleError(error) {
        const postMortem = this.generatePostMortem(error);
        
        const postMortemFile = path.join(this.projectRoot, 'LOG_POSTMORTEM.md');
        fs.appendFileSync(postMortemFile, postMortem, 'utf8');
        
        console.log('üìù Post-mortem g√©n√©r√© pour apprentissage');
        console.log('üîÑ Suggestions d\'am√©lioration disponibles dans LOG_POSTMORTEM.md');
    }

    /**
     * Enregistrement des √©tapes
     */
    logStep(stepName, status, details) {
        const step = {
            name: stepName,
            status: status,
            timestamp: new Date().toISOString(),
            details: details,
            duration: Date.now() - this.startTime
        };
        
        this.steps.push(step);
        
        const statusIcon = {
            'SUCCESS': '‚úÖ',
            'WARNING': '‚ö†Ô∏è',
            'ERROR': '‚ùå',
            'INFO': 'üìã'
        }[status] || 'üìã';
        
        console.log(`${statusIcon} ${stepName}: ${status}`);
    }

    /**
     * G√©n√©ration message de commit intelligent
     */
    generateSmartCommitMessage() {
        const timestamp = new Date().toISOString().slice(0, 19);
        const successSteps = this.steps.filter(s => s.status === 'SUCCESS').length;
        const totalSteps = this.steps.length;
        
        return `feat: Dev:IA orchestrated update (${successSteps}/${totalSteps} steps) - ${timestamp}`;
    }

    /**
     * G√©n√©ration rapport d√©taill√©
     */
    generateDetailedReport(duration) {
        const successCount = this.steps.filter(s => s.status === 'SUCCESS').length;
        const warningCount = this.steps.filter(s => s.status === 'WARNING').length;
        const errorCount = this.steps.filter(s => s.status === 'ERROR').length;
        
        return `# üìä Rapport Dev:IA Orchestrator

## üéØ R√©sum√© Ex√©cution
- **Date**: ${new Date().toISOString()}
- **Dur√©e**: ${duration}ms
- **Statut**: ${errorCount === 0 ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC'}

## üìã D√©tail des √âtapes
| √âtape | Statut | Dur√©e | D√©tails |
|-------|--------|-------|---------|
${this.steps.map(step => `| ${step.name} | ${step.status} | ${step.duration}ms | ${step.details.slice(0, 50)}... |`).join('\n')}

## üìä M√©triques
- ‚úÖ **Succ√®s**: ${successCount}
- ‚ö†Ô∏è **Warnings**: ${warningCount}  
- ‚ùå **Erreurs**: ${errorCount}

## üéØ Qualit√© Workflow
- **Efficacit√©**: ${(successCount / this.steps.length * 100).toFixed(1)}%
- **Fiabilit√©**: ${errorCount === 0 ? '100%' : '√Ä am√©liorer'}

---
*G√©n√©r√© automatiquement par Dev:IA Orchestrator v2.0*
`;
    }

    /**
     * G√©n√©ration post-mortem pour apprentissage
     */
    generatePostMortem(error) {
        return `
## [${new Date().toISOString()}] - √âchec Dev:IA Orchestrator

### üéØ Contexte
- **√âtape √©chou√©e** : ${this.steps[this.steps.length - 1]?.name || 'Inconnu'}
- **Erreur** : ${error.message}
- **Dur√©e avant √©chec** : ${Date.now() - this.startTime}ms

### üîç Analyse Racine
- **Cause probable** : Validation bloquante √©chou√©e
- **Impact** : Workflow interrompu
- **R√©currence** : ${this.isRecurringError(error) ? 'OUI' : 'NON'}

### üí° Suggestions d'Am√©lioration
- [ ] Renforcer les pr√©conditions pour cette √©tape
- [ ] Ajouter une validation pr√©alable
- [ ] Impl√©menter un mode de r√©cup√©ration automatique
- [ ] Am√©liorer les messages d'erreur

### üìà Apprentissage
- Pattern d'erreur √† surveiller dans les prochaines ex√©cutions
- Consid√©rer l'ajout d'une gate de qualit√© pr√©ventive

---
`;
    }

    /**
     * D√©tection d'erreurs r√©currentes
     */
    isRecurringError(error) {
        // Logique simple pour d√©tecter la r√©currence
        // √Ä am√©liorer avec une vraie base de donn√©es d'historique
        return error.message.includes('test') || error.message.includes('lint');
    }
}

// Ex√©cution
if (require.main === module) {
    const orchestrator = new DevIAOrchestrator();
    
    orchestrator.execute()
        .then(success => {
            process.exit(success ? 0 : 1);
        })
        .catch(error => {
            console.error('üí• Erreur fatale:', error);
            process.exit(1);
        });
}

module.exports = DevIAOrchestrator;
