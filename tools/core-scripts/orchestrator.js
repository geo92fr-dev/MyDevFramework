#!/usr/bin/env node

/**
 * UTIL_dev_ia_orchestrator.js - Orchestrateur de d√©veloppement guid√© par IA
 * Usage: npm run dev:ia [prompt-file]
 * 
 * Syst√®me autonome qui encapsule tout le workflow de d√©veloppement
 */

const fs = require('fs');
const path = require('path');
const { execSync, exec } = require('child_process');

class DevIAOrchestrator {
    constructor() {
        this.config = {
            name: 'FunLearning Dev:IA Orchestrator',
            version: '1.0.0',
            startTime: Date.now()
        };
        
        // Charger les niveaux de contr√¥le
        this.controlLevels = this.loadControlLevels();
        this.currentControlLevel = this.controlLevels.currentMode || 'controlled';
        
        this.metrics = {
            validationTime: 0,
            codeGenerationTime: 0,
            testTime: 0,
            qualityTime: 0,
            totalTime: 0,
            success: false,
            errors: [],
            warnings: []
        };

        this.postMortem = {
            incidents: [],
            learnings: [],
            improvements: []
        };

        // Quality gates adapt√©s au niveau de contr√¥le
        this.qualityGates = this.getAdaptiveQualityGates();
    }

    loadControlLevels() {
        try {
            const configPath = path.join(__dirname, '..', 'CONFIG_control_levels.json');
            return JSON.parse(fs.readFileSync(configPath, 'utf8'));
        } catch (error) {
            console.log('‚ö†Ô∏è Configuration de contr√¥le non trouv√©e, utilisation des d√©fauts');
            return { currentMode: 'controlled', controlLevels: {} };
        }
    }

    getAdaptiveQualityGates() {
        const level = this.controlLevels.controlLevels[this.currentControlLevel];
        
        if (!level) {
            // D√©fauts si configuration manquante
            return {
                'phase-0': { complexity: 5, coverage: 70, security: 'medium' },
                'phase-1': { complexity: 7, coverage: 80, security: 'high' },
                'phase-2': { complexity: 8, coverage: 85, security: 'high' },
                'phase-3': { complexity: 8, coverage: 85, security: 'high' },
                'phase-4': { complexity: 9, coverage: 90, security: 'high' },
                'phase-5': { complexity: 9, coverage: 90, security: 'high' },
                'phase-6': { complexity: 10, coverage: 95, security: 'critical' }
            };
        }

        // Adapter selon le niveau de contr√¥le
        const baseCoverage = level.quality.minTestCoverage;
        const baseComplexity = level.quality.maxComplexity;
        
        return {
            'phase-0': { complexity: Math.max(baseComplexity - 5, 3), coverage: baseCoverage, security: 'medium' },
            'phase-1': { complexity: Math.max(baseComplexity - 3, 5), coverage: baseCoverage + 10, security: 'high' },
            'phase-2': { complexity: Math.max(baseComplexity - 2, 6), coverage: baseCoverage + 15, security: 'high' },
            'phase-3': { complexity: Math.max(baseComplexity - 2, 6), coverage: baseCoverage + 15, security: 'high' },
            'phase-4': { complexity: Math.max(baseComplexity - 1, 7), coverage: baseCoverage + 20, security: 'high' },
            'phase-5': { complexity: Math.max(baseComplexity - 1, 7), coverage: baseCoverage + 20, security: 'high' },
            'phase-6': { complexity: baseComplexity, coverage: baseCoverage + 25, security: 'critical' }
        };
    }

    log(level, message, force = false) {
        const timestamp = new Date().toISOString();
        const emoji = {
            'info': 'üìã',
            'success': '‚úÖ',
            'warning': '‚ö†Ô∏è',
            'error': '‚ùå',
            'debug': 'üîç'
        };
        
        console.log(`[${timestamp}] ${emoji[level]} ${message}`);
        
        if (level === 'error') {
            this.metrics.errors.push({ timestamp, message });
        } else if (level === 'warning') {
            this.metrics.warnings.push({ timestamp, message });
        }
    }

    async executeCommand(command, description, timeout = 30000) {
        this.log('info', `üöÄ ${description}...`);
        const startTime = Date.now();
        
        try {
            const result = execSync(command, { 
                encoding: 'utf8',
                timeout: timeout,
                stdio: ['inherit', 'pipe', 'pipe']
            });
            
            const duration = Date.now() - startTime;
            this.log('success', `${description} completed in ${duration}ms`);
            return { success: true, output: result, duration };
        } catch (error) {
            const duration = Date.now() - startTime;
            this.log('error', `${description} failed: ${error.message}`);
            
            // Log pour post-mortem
            this.postMortem.incidents.push({
                timestamp: new Date().toISOString(),
                command,
                description,
                error: error.message,
                duration
            });
            
            return { success: false, error: error.message, duration };
        }
    }

    async validateCheckBeforingDoing() {
        this.log('info', 'üìã Phase 1: Validation CheckBeforingDoing...');
        const startTime = Date.now();
        
        const result = await this.executeCommand(
            'npm run validate:checkbeforedoing',
            'Validation du protocole CheckBeforeDoing'
        );
        
        this.metrics.validationTime = Date.now() - startTime;
        return result.success;
    }

    async validateRoadmap() {
        this.log('info', 'üó∫Ô∏è Phase 2: Validation roadmap...');
        
        const result = await this.executeCommand(
            'npm run validate:roadmap',
            'V√©rification conformit√© roadmap'
        );
        
        return result.success;
    }

    async validateReadme() {
        this.log('info', 'üìö Phase 2b: Validation README central...');
        
        const result = await this.executeCommand(
            'npm run validate:readme',
            'V√©rification hub documentation'
        );
        
        return result.success;
    }

    async validateDocumentation() {
        this.log('info', 'üìù Phase 2c: Validation documentation automatique...');
        
        const result = await this.executeCommand(
            'npm run docs:validate',
            'V√©rification commentaires documentation'
        );
        
        return result.success;
    }

    async synchronizeGit() {
        this.log('info', 'üîÑ Phase 3: Synchronisation Git...');
        
        // V√©rifier l'√©tat Git
        const statusResult = await this.executeCommand(
            'git status --porcelain',
            'V√©rification √©tat Git'
        );
        
        if (statusResult.output.trim()) {
            this.log('warning', 'Modifications non commit√©es d√©tect√©es');
        }
        
        // V√©rifier si un remote existe
        const remoteResult = await this.executeCommand(
            'git remote -v',
            'V√©rification remote Git'
        );
        
        if (!remoteResult.output.trim()) {
            this.log('info', 'Aucun remote configur√© - synchronisation Git ignor√©e');
            return true; // Pas d'erreur si pas de remote
        }
        
        // V√©rifier le tracking de la branche
        const trackingResult = await this.executeCommand(
            'git status -b --porcelain',
            'V√©rification tracking branch'
        );
        
        if (trackingResult.output.includes('no upstream')) {
            this.log('warning', 'Branche sans tracking upstream - synchronisation ignor√©e');
            return true; // Pas d'erreur si pas de tracking
        }
        
        // Pull rebase seulement si remote et tracking configur√©s
        const pullResult = await this.executeCommand(
            'git pull --rebase',
            'Synchronisation avec remote'
        );
        
        return pullResult.success;
    }

    async runQualityAnalysis(phase = 'phase-0') {
        this.log('info', 'üîç Phase 4: Analyse qualit√©...');
        const startTime = Date.now();
        
        const gates = this.qualityGates[phase] || {
            coverage: { minimum: 70 },
            complexity: { max: 10 },
            security: { level: 'medium' }
        };
        
        const results = {
            lint: false,
            tests: false,
            security: false
            // Retirer coverage et performance pour l'instant
        };

        // Linting
        const lintResult = await this.executeCommand(
            'npm run lint',
            'Analyse ESLint'
        );
        results.lint = lintResult.success;

        // Tests avec couverture
        const testResult = await this.executeCommand(
            'npm run test:coverage',
            `Tests avec couverture cible ${gates.coverage?.minimum || 70}%`
        );
        results.tests = testResult.success;

        // Audit s√©curit√© avec script personnalis√© pour d√©veloppement
        const securityResult = await this.executeCommand(
            'node scripts/UTIL_audit_security_dev.js',
            'Audit de s√©curit√© (mode dev)'
        );
        results.security = securityResult.success;

        this.metrics.qualityTime = Date.now() - startTime;
        
        const overallSuccess = Object.values(results).every(r => r);
        
        if (!overallSuccess) {
            this.log('error', '√âchec des gates de qualit√©');
            this.postMortem.incidents.push({
                timestamp: new Date().toISOString(),
                type: 'QUALITY_GATE_FAILURE',
                phase,
                results,
                gates
            });
        }
        
        return { success: overallSuccess, details: results };
    }

    async createCommit(context, changes) {
        this.log('info', 'üìù Phase 5: Cr√©ation commit...');
        
        // G√©n√©rer un message de commit intelligent
        const commitMessage = this.generateCommitMessage(context, changes);
        
        // Add files
        await this.executeCommand(
            'git add .',
            'Ajout des fichiers modifi√©s'
        );
        
        // Commit avec message enrichi
        const commitResult = await this.executeCommand(
            `git commit -m "${commitMessage}"`,
            'Cr√©ation commit atomique'
        );
        
        if (commitResult.success) {
            // Ajouter m√©tadonn√©es au commit
            await this.executeCommand(
                `git notes add -m "${JSON.stringify(this.metrics)}"`,
                'Ajout m√©tadonn√©es de performance'
            );
        }
        
        return commitResult.success;
    }

    generateCommitMessage(context, changes) {
        const timestamp = new Date().toISOString();
        const phase = this.extractPhase(context);
        
        const message = [
            `feat(${phase}): ${context}`,
            '',
            `ü§ñ G√©n√©r√© par Dev:IA Orchestrator`,
            `üìä M√©triques: ${this.metrics.validationTime}ms validation, ${this.metrics.qualityTime}ms qualit√©`,
            `üéØ Qualit√©: ${this.metrics.errors.length} erreurs, ${this.metrics.warnings.length} warnings`,
            `‚è±Ô∏è Timestamp: ${timestamp}`,
            '',
            'üîó Changements:',
            ...changes.map(change => `  - ${change}`)
        ].join('\n');
        
        return message.replace(/"/g, '\\"');
    }

    extractPhase(context) {
        const match = context.match(/Phase (\d+(?:\.\d+)?)/);
        return match ? `P${match[1]}` : 'unknown';
    }

    async generatePostMortemEntry() {
        if (this.postMortem.incidents.length === 0) return;
        
        const entry = {
            timestamp: new Date().toISOString(),
            incidents: this.postMortem.incidents,
            metrics: this.metrics,
            suggestions: this.generateImprovementSuggestions()
        };
        
        const logPath = path.join(__dirname, '..', '..', 'docs', 'LOG_POSTMORTEM.md');
        let logContent = '';
        
        if (fs.existsSync(logPath)) {
            logContent = fs.readFileSync(logPath, 'utf8');
        } else {
            logContent = '# Log Post-Mortem - Apprentissage Continu\n\n';
        }
        
        const newEntry = this.formatPostMortemEntry(entry);
        logContent += newEntry;
        
        fs.writeFileSync(logPath, logContent);
        this.log('info', `üìù Entr√©e post-mortem ajout√©e √† ${logPath}`);
    }

    formatPostMortemEntry(entry) {
        return `
## ${entry.timestamp} - Session Dev:IA

### üéØ M√©triques de Performance
- **Validation** : ${entry.metrics.validationTime}ms
- **Qualit√©** : ${entry.metrics.qualityTime}ms
- **Erreurs** : ${entry.metrics.errors.length}
- **Warnings** : ${entry.metrics.warnings.length}
- **Succ√®s** : ${entry.metrics.success ? '‚úÖ' : '‚ùå'}

### üîç Incidents D√©tect√©s
${entry.incidents.map(incident => `
- **${incident.description}** : ${incident.error}
  - Commande : \`${incident.command}\`
  - Dur√©e : ${incident.duration}ms
`).join('')}

### üí° Suggestions d'Am√©lioration
${entry.suggestions.map(suggestion => `- ${suggestion}`).join('\n')}

---
`;
    }

    generateImprovementSuggestions() {
        const suggestions = [];
        
        if (this.metrics.validationTime > 5000) {
            suggestions.push('‚ö° Optimiser les scripts de validation (> 5s)');
        }
        
        if (this.metrics.errors.length > 0) {
            suggestions.push('üõ°Ô∏è Renforcer les validations pr√©ventives');
        }
        
        if (this.metrics.warnings.length > 5) {
            suggestions.push('üìã R√©viser les seuils d\'alerte (trop de warnings)');
        }
        
        return suggestions;
    }

    async generateReport() {
        const totalTime = Date.now() - this.config.startTime;
        this.metrics.totalTime = totalTime;
        
        console.log('\n' + '='.repeat(60));
        console.log('üìä RAPPORT DEV:IA ORCHESTRATOR');
        console.log('='.repeat(60));
        
        console.log(`\nüéØ Session: ${this.config.name}`);
        console.log(`‚è±Ô∏è Dur√©e totale: ${totalTime}ms`);
        console.log(`üìà Statut: ${this.metrics.success ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC'}`);
        
        console.log(`\nüìä M√©triques d√©taill√©es:`);
        console.log(`  Validation CheckBeforeDoing: ${this.metrics.validationTime}ms`);
        console.log(`  Analyse qualit√©: ${this.metrics.qualityTime}ms`);
        console.log(`  Erreurs: ${this.metrics.errors.length}`);
        console.log(`  Warnings: ${this.metrics.warnings.length}`);
        
        if (this.metrics.errors.length > 0) {
            console.log(`\n‚ùå Erreurs rencontr√©es:`);
            this.metrics.errors.forEach((error, index) => {
                console.log(`  ${index + 1}. ${error.message}`);
            });
        }
        
        if (this.metrics.warnings.length > 0) {
            console.log(`\n‚ö†Ô∏è Warnings:`);
            this.metrics.warnings.forEach((warning, index) => {
                console.log(`  ${index + 1}. ${warning.message}`);
            });
        }
        
        console.log('\n' + '='.repeat(60));
    }

    async orchestrate(context = 'D√©veloppement guid√© par IA', changes = []) {
        this.log('info', 'üöÄ D√©marrage de l\'orchestrateur Dev:IA');
        
        try {
            // Phase 1: Validation CheckBeforeDoing
            const checkBeforeDoingValid = await this.validateCheckBeforeDoing();
            if (!checkBeforeDoingValid) {
                throw new Error('Validation CheckBeforeDoing √©chou√©e');
            }
            
            // Phase 2: Validation roadmap
            const roadmapValid = await this.validateRoadmap();
            if (!roadmapValid) {
                this.log('warning', 'Validation roadmap √©chou√©e - mode d√©viation');
                // En mode d√©viation, on continue mais on flag
            }
            
            // Phase 2b: Validation README central
            const readmeValid = await this.validateReadme();
            if (!readmeValid) {
                this.log('warning', 'README central incomplet - documentation √† synchroniser');
            }
            
            // Phase 2c: Validation documentation automatique
            const docsValid = await this.validateDocumentation();
            if (!docsValid) {
                this.log('warning', 'Documentation code incompl√®te - commentaires @criticality/@description manquants');
            }
            
            // Phase 3: Synchronisation Git
            const gitSync = await this.synchronizeGit();
            if (!gitSync) {
                this.log('warning', 'Synchronisation Git √©chou√©e');
            }
            
            // Phase 4: Analyse qualit√©
            const phase = this.extractPhase(context);
            const qualityCheck = await this.runQualityAnalysis(`phase-${phase.replace('P', '')}`);
            
            if (!qualityCheck.success) {
                throw new Error('Gates de qualit√© non respect√©es');
            }
            
            // Phase 5: Commit si tout OK
            if (changes.length > 0) {
                const commitSuccess = await this.createCommit(context, changes);
                if (!commitSuccess) {
                    throw new Error('√âchec de cr√©ation du commit');
                }
            }
            
            this.metrics.success = true;
            this.log('success', 'üéâ Orchestration termin√©e avec succ√®s !');
            
        } catch (error) {
            this.metrics.success = false;
            this.log('error', `üí• Orchestration √©chou√©e: ${error.message}`);
        } finally {
            await this.generatePostMortemEntry();
            await this.generateReport();
        }
        
        return this.metrics.success;
    }
}

// CLI Usage
if (require.main === module) {
    const args = process.argv.slice(2);
    const context = args[0] || 'D√©veloppement guid√© par IA';
    const changes = args.slice(1) || [];
    
    const orchestrator = new DevIAOrchestrator();
    orchestrator.orchestrate(context, changes)
        .then(success => {
            process.exit(success ? 0 : 1);
        })
        .catch(error => {
            console.error('Erreur fatale:', error);
            process.exit(1);
        });
}

module.exports = DevIAOrchestrator;
